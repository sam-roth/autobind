
#include "Module.hpp"

namespace autobind {

void Module::codegenDeclaration(std::ostream &out) const
{
	assert(!_sourceTUPath.empty());

	for(int i = 0; i < 10; ++i)
	{
		out << "//\n";
	}
	out << "// AUTOGENERATED CONTENT. DO NOT MODIFY.\n";
	out << "//   I'M SERIOUS. THIS WILL GET OVERWRITTEN.\n";
	out << "//      YES WAY.\n";
	for(int i = 0; i < 10; ++i)
	{
		out << "//\n";
	}

	out << "#include <Python.h>\n";
	out << "#include \"autobind.hpp\"\n";


	for(const auto &e : _exports)
	{
		e->codegenDeclaration(out);
	}
	out << boost::format("#include \"%s\"\n") % _sourceTUPath;
}

void Module::codegenDefinition(std::ostream &out) const
{
	for(const auto &e : _exports)
	{
		e->codegenDefinition(out);
	}
}
void Module::codegenMethodTable(std::ostream &out) const
{
	out << "static PyMethodDef methods[] = {\n";
	{
		IndentingOStreambuf indenter(out);
		for(const auto &e : _exports)
		{
			e->codegenMethodTable(out);
		}

		out << "{0, 0, 0, 0}\n";
	}

	out << "};\n";
}
void Module::codegenModuleDef(std::ostream &out) const 
{
	out << "static struct PyModuleDef module = {\n";
	{
		IndentingOStreambuf indenter(out);

		auto docstring = processDocString(_docstring);

		out  
			<< "PyModuleDef_HEAD_INIT,\n"
			<< "\"" << name() << "\",\n"
			<< "\"" << docstring << "\",\n"
			<< "-1,\n"
			<< "methods\n";
	}
	out << "};\n";
}

void Module::codegenInit(std::ostream &out) const
{
	out
		<< "PyMODINIT_FUNC PyInit_" << name() << "()\n"
		<< "{\n"
		<< "    PyObject *mod = PyModule_Create(&module);\n"
		<< "    if(!mod) return 0;\n";


	{
		IndentingOStreambuf indenter(out);
		for(const auto &e : _exports)
		{
			e->codegenInit(out);
		}
	}


	out << "    return mod;\n}\n";
}

void Module::codegen(std::ostream &out) const
{
	codegenDeclaration(out);
	codegenDefinition(out);
	codegenMethodTable(out);
	codegenModuleDef(out);
	codegenInit(out);
}

} // autobind

